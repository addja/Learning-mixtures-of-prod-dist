####################
# Implementation of the algorithm presented on
# 'Estimating a mixture of two product distributions'
# by Freund and Mansour
#	https://cseweb.ucsd.edu/~yfreund/papers/mixtureOfTwoProductDists.pdf
# March 2018
####################

import numpy as np

def likelihood(samples,d1,d2,g):
	m = samples.shape[0]
	sumSamples = samples.sum(axis=0)
	avg = sumSamples/m
	theta1 = g*(d1+d2)
	theta2 = (1-g)*(np.ones(d1.shape)-d1+np.ones(d2.shape)+d2)
	lhood = (theta1**sumSamples)*(theta2**(m-sumSamples))
	return np.sum(lhood)

## Pre:
#	samples:	m*n matrix with m samples from the original mixture
#	subset:		list of indices of a subset of samples
## Post:
#	array containing the approximate means for the product distributions
#	restricted to the input subset
#	array containing the approximate mixing rates for the product distributions
#	restricted to the input subset
def estimateSet(samples,subset1,subset2):
	m = samples.shape[0]
	N = 1	# TODO
	maxp1 = 0; maxp2 = 0; maxgamma = 0; ml = 0;

	for q in range(N):
		# choose a random vector from samples uniformly at random
		x = np.random.randint(m)

		# compute threshold
		dotProd = np.dot(samples[:,subset1],samples[x,subset1])
		theta = np.sum(dotProd)/m

		# split sample set using the calculated threshold
		subsamples = np.where(dotProd <= theta)[0]
		subsamples = samples[subsamples]

		# calculate average for subset2 values of samples and sample2
		avg1 = samples[:,subset2].sum(axis=0)/m
		avg2 = subsamples[:,subset2].sum(axis=0)/m

		# calculate spacing parameters and limits
		lambda1 = 0.01		# TODO
		lambda2 = 0.01		# TODO
		beta 	= 1			# TODO
		bound1	= 1		# TODO
		bound2	= 1		# TODO

		# grid over the line generated by qsa qss with the calculated spacing and
		# return the model with maximum likelihood
		for i in range(-bound1,bound1):
			p1 = avg1 - (avg2+i*lambda1)
			for j in range (i,bound1):
				p2 = avg1 - (avg2+j*lambda1)
				for k in np.arange(-bound2,bound2):   # technically 0
					gamma = k*lambda2
					tmp = likelihood(samples[:,subset2],p1,p2,gamma)
					if tmp >= ml:
						ml = tmp; maxp1 = p1; maxp2 = p2; maxgamma = gamma

	return maxp1,maxp2,maxgamma


## Pre:
#	epsilon:	error bound
#	delta:		probability of failure
#	samples:	m*n matrix with m samples from the original mixture
## Post:
#	adist:	array of the approximatated means of the product distributions
#	arates:	approximate mixing rates of product distributions
## Assumtions:
#	the original prodict distributions on the mixtures has a non-negligible
#	distance between them
def FreundMansour(epsilon,delta,samples):
	m = samples.shape[0]
	n = samples.shape[1]

	# compute the average of sample and compute the likelihood
	# it generated such samples
	sumSamples = samples.sum(axis=0)
	avg = sumSamples/m
	lhavg = (avg**sumSamples)*(1-avg)**(m-sumSamples) # TODO WHY!!!!

	# iterate keeping the model with maximum likelihood
	nit = int(np.ceil(np.log(2/delta)))
	maxp1 = 0; maxp2 = 0; maxgamma = 0; ml = 0;
	for i in range(nit):
		# split sample into two sets with coordinate probabilities of 0.5
		split = np.random.choice(2,n)
		setS1 = np.where(split==1)[0]
		setS2 = np.where(split==0)[0]
		# call estimateSet with both splits
		a1,b1,g1 = estimateSet(samples,setS1,setS2)
		a2,b2,g2 = estimateSet(samples,setS2,setS1)

		# get the combination with maximum likelihood
		h1 = np.zeros([n,])
		h2 = np.zeros([n,])
		# a1||a2 b1||b2 g1
		h1[setS1]=a2
		h1[setS2]=a1
		h2[setS1]=b2
		h2[setS2]=b1
		tmp = likelihood(samples,h1,h2,g1)
		if tmp > ml:
			maxp1 = h1; maxp2 = h2; maxgamma = g1; ml = tmp;

		# p1s1||p1s2 p2s1||p2s2 g2
		tmp = likelihood(samples,h1,h2,g2)
		if tmp > ml:
			maxp1 = h1; maxp2 = h2; maxgamma = g2; ml = tmp;

	# prepare distribution for output
	p1 = np.vstack((np.ones([n,])-maxp1,maxp1))
	p2 = np.vstack((np.ones([n,])-maxp2,maxp2))
	res = np.ndarray([2,n,2])
	res[0,:,:] = p1.transpose(); res[1,:,:] = p2.transpose()
	g = np.ndarray([2,]); g[0] = 1-maxgamma; g[1] = maxgamma
	return res,g
