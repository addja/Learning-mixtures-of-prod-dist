####################
# Implementation of the algorithm presented on
# 'Estimating a mixture of two product distributions'
# by Freund and Mansour
#	https://cseweb.ucsd.edu/~yfreund/papers/mixtureOfTwoProductDists.pdf
# March 2018
####################

import numpy as np


## Pre:
#	samples:	m*n matrix with m samples from the original mixture
#	subset:		list of indices of a subset of samples
## Post:
#	array containing the approximate means for the product distributions
#	restricted to the input subset
#	array containing the approximate mixing rates for the product distributions
#	restricted to the input subset
def estimateSet(samples,subset1,subset2):
	m = samples.shape[0]

	# choose a random vector from samples uniformly at random
	x = np.random.randint(m)

	# compute threshold
	dotProd = np.dot(samples[:,subset1],samples[x,subset1])
	theta = np.sum(dotProd)/m

	# split sample set using the calculated threshold
	subsamples = np.where(dotProd <= theta)[0]
	subsamples = samples[subsamples]

	# calculate average for subset2 values of samples and sample2
	avg1 = samples[:,subset2].sum(axis=0)/m
	avg2 = subsamples[:,subset2].sum(axis=0)/m

	# calculate spacing parameters and limits
	dlambda = 0.1*(avg1-avg2)
	mlambda = 0.01
	limit = 1		# TODO

	# grid over the line generated by qsa qss with the calculated spacing and
	# return the model with maximum likelihood
	maxp1 = 0; maxp2 = 0; maxgamma = 0;
	for i in range(0,limit,dlambda):
		p1 = avg1 - (avg2+i)
		for j in range (i,limit,dlambda):
			p2 = avg1 - (avg2+j)
			for gamma in range(0,1,mlambda):
				tmp = maxLikelihood(subsamples,p1,p2,gamma)
				if tmp > ml:
					ml = tmp
					maxp1 = p1
					maxp2 = p2
					maxgamma = gamma

	return maxp1,maxp2,maxgamma


## Pre:
#	epsilon:	error bound
#	delta:		probability of failure
#	samples:	m*n matrix with m samples from the original mixture
## Post:
#	adist:	array of the approximatated means of the product distributions
#	arates:	approximate mixing rates of product distributions
def FreundMansour(epsilon,delta,samples):
	m = samples.shape[0]
	n = samples.shape[1]

	# compute the average of sample and compute the likelihood
	# it generated such samples
	sumSamples = samples.sum(axis=0)
	avg = sumSamples/m
	lhavg = (avg**sumSamples)*(1-avg)**(m-sumSamples)

	# iterate keeping the model with maximum likelihood
	nit = int(np.ceil(np.log(2/delta)))
	maxp1 = 0; maxp2 = 0; maxgamma = 0;
	for i in range(nit):
		# split sample into two sets with coordinate probabilities of 0.5
		split = np.random.choice(2,n)
		setS1 = np.where(split==1)[0]
		setS2 = np.where(split==0)[0]
		# call estimateSet with both splits
		p11,p21,g1 = estimateSet(samples,setS1,setS2)
		p12,p22,g2 = estimateSet(samples,setS2,setS1)
		break

		# get the combination with maximal maxLikelihood
		# p11p12 p21p22 g1
		# p11p12 p21p22 g2
		# p11p22 p21p12 g1
		# p11p22 p21p12 g2

	# return maxp1,maxp2,maxgamma

	print('done')
